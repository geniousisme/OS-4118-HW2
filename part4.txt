4. Investigate the Android process tree

a. Run your test program several times. Which fields in the prinfo structure 
change? Which ones do not? Discuss why different fields might change with 
different frequency.

Ans:
    We ran ptree for five times, and the following is the result we get for the 
part that has changed:

    1. adbd,59,1,1,1024,0,0
                ptree_test,1024,0,59,0,0,0

    2. adbd,59,1,1,1028,0,0
                ptree_test,1028,0,59,0,0,0

    3. adbd,59,1,1,1033,0,0
                ptree_test,1033,0,59,0,0,0

    4. adbd,59,1,1,1035,0,0
                ptree_test,1035,0,59,0,0,0

    5. adbd,59,1,1,1037,0,0
                ptree_test,1037,0,59,0,0,0

    in out ptree_test, the display order is like this:
        - program name
        - process id
        - state of the process
        - parent process id
        - first child process id
        - next sibling process id

the only thing change is the first child id of adbd and also the process id of 
the ptree, and the other things don't change too much. It is because those other 
programs exist since the system turn on, and while we run the ptree_test, we 
just use adbd to run the file. As the result, the other programs don't change 
anything, for example, their owner process doesn't change, parent process 
doesn't die, and process don't change.

    And why do adbd first child process id and ptree_test parent id change? It 
is because adbd is the parent process of ptree, and when we re-run the ptree, 
adbd will assign a new child process for ptree and ptree will get a new process 
id. The fields may change with different frequency since current processes on 
the system have different pids and states from time to time. Also, the process 
would go away or be forked or re-parented with a different frequency.


b. Start the mobile web browser in the emulator, and re-run your test program. 
How many processes are started? What is/are the parent process(es) of the new 
process(es)? Close the browser (press the "Home" button). How many processes 
were destroyed? Discuss your findings.

Ans:
    when we start the mobile web browser, the only new process is the following:

        android.browser,1026,1,51,0,0,10014

    and the parent process of this process is:

        zygote,51,1,1,368,52,0

    When we click the Home button to close the browser, no process is gone or 
destroyed, even after few hours, the browser process still exist. So we think 
that hitting the home button doesn't kill the process of browser, it will 
probably just put it into the background to make it sleep. However, we find that 
when we use the real closing way to close the browser (drag it from left to 
right), the process will be destroyed. We think that it is the real way to close 
a process in Android.



c. Notice that on the Android platform there is a process named zygote. 
Investigate this process and any children processes:
i. What is the purpose of this process?

Ans:
    Zygote, just like its name, is an initial system services process and start 
at init (which is specified in the init.rc file). Also, zygote is the parent 
process of all application process. Besides, zygote has all core libraries of 
Android OS without duplication and can only allow the use of existing read-only 
in this single process. As the result, when an application starts, a message 
will be sent to zygote process, and fork system call starts. Therefore, the 
application starting time can be reduced.

ii. Where is the zygote binary? If you can't find it, how might you explain its 
presence in your list of processes?

Ans:
    There is no zygote binary in Android. However, it is in the 
/system/bin/app_process. We found this by investigating the /proc structure. 
Though there are no programs called zygote, zygote process binary is created by 
init process, which is specified in init.rc, and copies the core libraries.

iii. Discuss some reasons why an embedded system might choose to use a process 
like the zygote.
HINT: A key feature of embedded systems is their resource limitations.

Ans:
    Since embedded system has a very limited resource, it would be too expensive 
for embedded system to let each process to copy their core libraries. Letting 
zygote share the core libraries with another application process without 
duplication can save a lot of resources. Furthermore, since embedded system 
seldom changes its core libraries, making zygote have all core libraries first 
can accelerate the speed of starting a new application process. Therefore, the 
resource of embedded system can be saved, and the speed can be raised.
